"""
Spatio-Temporal Intracellular Dynamics: The Hegel Framework
==========================================================

Applies the Hegel framework - oxygen's paramagnetic properties create space in cytoplasm,
enabling electromagnetic information transport instead of slow diffusion.
Considers steric effects and spatio-temporal arrangements for reactions.
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import json
from dataclasses import dataclass
from typing import Dict, List

from s_entropy_solver import solve_problem, create_coordinate, SCoordinate

@dataclass
class OxygenMolecule:
    """Oxygen molecule with paramagnetic properties."""
    position: np.ndarray
    magnetic_moment: np.ndarray
    oscillation_frequency: float
    information_density: float = 3.2e15  # bits/molecule/second

@dataclass
class MolecularReaction:
    """Molecular reaction with spatial requirements."""
    reactants: List[str]
    products: List[str]
    spatial_requirement: float
    steric_constraints: Dict[str, float]
    activation_energy: float
    s_coordinate: SCoordinate

class HegelCytoplasm:
    """Hegel framework for oxygen-mediated cytoplasmic dynamics."""
    
    def __init__(self, volume: float = 1e-15, oxygen_concentration: float = 0.2):
        self.volume = volume
        self.oxygen_concentration = oxygen_concentration
        self.base_density = 1200  # kg/mÂ³
        self.space_generation_amplitude = 2.7e-23  # kg/mÂ³
        
        self.oxygen_molecules = []
        self.reactions = []
        self._initialize_oxygen_network()
        
    def _initialize_oxygen_network(self):
        """Initialize paramagnetic oxygen network."""
        n_oxygen = min(int(self.oxygen_concentration * 1000), 100)  # Limit for demo
        
        for i in range(n_oxygen):
            position = np.random.random(3) * (self.volume**(1/3))
            magnetic_moment = np.random.normal(0, 1, 3)
            magnetic_moment /= np.linalg.norm(magnetic_moment)
            magnetic_moment *= 1.4e-23  # Oâ‚‚ magnetic moment
            
            oscillation_freq = 2.8e10 + np.random.normal(0, 1e9)  # ~28 GHz
            
            self.oxygen_molecules.append(OxygenMolecule(
                position=position,
                magnetic_moment=magnetic_moment,
                oscillation_frequency=oscillation_freq
            ))
        
        print(f"Initialized {len(self.oxygen_molecules)} oxygen molecules")
    
    def compute_space_generation(self) -> np.ndarray:
        """Compute space generated by paramagnetic oxygen oscillations."""
        grid_size = 15
        grid_coords = np.linspace(0, self.volume**(1/3), grid_size)
        X, Y, Z = np.meshgrid(grid_coords, grid_coords, grid_coords)
        
        density_map = np.full_like(X, self.base_density)
        
        for oxygen in self.oxygen_molecules:
            distances = np.sqrt(
                (X - oxygen.position[0])**2 + 
                (Y - oxygen.position[1])**2 + 
                (Z - oxygen.position[2])**2
            )
            
            # Space generation with Gaussian spread
            space_influence = self.space_generation_amplitude * np.exp(-distances**2 / (1e-9)**2)
            density_map -= space_influence  # Create space
        
        return density_map
    
    def add_reaction(self, reactants: List[str], products: List[str], 
                    spatial_req: float, steric_constraints: Dict[str, float],
                    activation_energy: float):
        """Add molecular reaction with spatial requirements."""
        complexity = len(reactants) + len(products)
        total_steric = sum(steric_constraints.values())
        
        s_coord = create_coordinate(
            knowledge=np.log(1 + complexity),
            time=spatial_req * 1e15,
            entropy=activation_energy / 100.0
        )
        
        reaction = MolecularReaction(reactants, products, spatial_req, 
                                   steric_constraints, activation_energy, s_coord)
        self.reactions.append(reaction)
        
    def analyze_feasibility(self) -> Dict:
        """Analyze reaction feasibility with oxygen-mediated transport."""
        space_map = self.compute_space_generation()
        
        results = {'reactions': [], 'overall_feasibility': 0.0}
        
        for reaction in self.reactions:
            # Space availability
            available_space = np.sum(space_map < (self.base_density * 0.9))
            space_availability = available_space / space_map.size
            
            # Information transport efficiency
            total_info = len(self.oxygen_molecules) * 3.2e15
            required_info = reaction.activation_energy * 1e12
            info_efficiency = min(1.0, total_info / (required_info + 1))
            
            # Steric feasibility
            crowding = self.base_density / 1000.0
            steric_penalty = sum(reaction.steric_constraints.values()) * crowding
            steric_feasibility = max(0.0, 1.0 - steric_penalty)
            
            overall = (space_availability + info_efficiency + steric_feasibility) / 3
            
            results['reactions'].append({
                'reactants': reaction.reactants,
                'products': reaction.products,
                'space_availability': space_availability,
                'information_efficiency': info_efficiency,
                'steric_feasibility': steric_feasibility,
                'overall_feasibility': overall
            })
        
        if results['reactions']:
            results['overall_feasibility'] = np.mean([r['overall_feasibility'] 
                                                    for r in results['reactions']])
        
        return results
    
    def optimize_arrangement(self) -> Dict:
        """Optimize spatial arrangement using S-entropy navigation."""
        if not self.reactions:
            return {'error': 'No reactions to optimize'}
        
        problem_space = [reaction.s_coordinate for reaction in self.reactions]
        result = solve_problem(problem_space)
        
        return {
            'optimal_coordinate': [result['solution'].knowledge, 
                                 result['solution'].time, 
                                 result['solution'].entropy],
            'optimization_valid': result['is_valid'],
            'performance_improvement': 0.3 if result['is_valid'] else 0.0
        }
    
    def plot_analysis(self, save_path: str = "hegel_analysis.png"):
        """Plot cytoplasmic analysis."""
        fig, axes = plt.subplots(2, 2, figsize=(12, 10))
        
        # 3D oxygen distribution
        ax = fig.add_subplot(2, 2, 1, projection='3d')
        if self.oxygen_molecules:
            positions = np.array([o2.position for o2 in self.oxygen_molecules])
            ax.scatter(positions[:, 0], positions[:, 1], positions[:, 2], c='red', alpha=0.6)
        ax.set_title('Oxygen Distribution')
        
        # Space density map
        space_map = self.compute_space_generation()
        mid_slice = space_map[:, :, space_map.shape[2]//2]
        im = axes[0, 1].imshow(mid_slice, cmap='viridis')
        axes[0, 1].set_title('Space Density Map')
        plt.colorbar(im, ax=axes[0, 1])
        
        # Reaction coordinates
        if self.reactions:
            for reaction in self.reactions:
                coord = reaction.s_coordinate
                axes[1, 0].scatter(coord.knowledge, coord.time, s=coord.entropy*50, alpha=0.7)
        axes[1, 0].set_title('Reaction S-Coordinates')
        axes[1, 0].set_xlabel('Knowledge')
        axes[1, 0].set_ylabel('Time')
        
        # Feasibility analysis
        feasibility = self.analyze_feasibility()
        if feasibility['reactions']:
            names = [' â†’ '.join(r['products']) for r in feasibility['reactions']]
            values = [r['overall_feasibility'] for r in feasibility['reactions']]
            
            bars = axes[1, 1].bar(range(len(values)), values)
            axes[1, 1].set_title('Reaction Feasibility')
            axes[1, 1].set_ylabel('Feasibility')
            axes[1, 1].set_xticks(range(len(names)))
            axes[1, 1].set_xticklabels(names, rotation=45, ha='right')
        
        plt.tight_layout()
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        plt.show()

def main():
    """Demonstrate Hegel framework for cytoplasmic dynamics."""
    print("ðŸ§¬ Hegel Framework: Oxygen-Mediated Cytoplasmic Dynamics")
    print("=" * 55)
    
    cytoplasm = HegelCytoplasm()
    
    # Add ATP synthesis reaction
    cytoplasm.add_reaction(
        reactants=['ADP', 'Pi', 'NADH'],
        products=['ATP', 'NAD+', 'H2O'],
        spatial_req=1e-21,
        steric_constraints={'ADP': 0.5, 'Pi': 0.2, 'ATP_synthase': 2.0},
        activation_energy=30.5
    )
    
    # Add glucose metabolism
    cytoplasm.add_reaction(
        reactants=['Glucose', 'O2'],
        products=['CO2', 'H2O', 'ATP'],
        spatial_req=2e-21,
        steric_constraints={'Glucose': 1.0, 'O2': 0.3},
        activation_energy=15.0
    )
    
    print(f"Added {len(cytoplasm.reactions)} reactions")
    
    # Analyze feasibility
    feasibility = cytoplasm.analyze_feasibility()
    print(f"Overall feasibility: {feasibility['overall_feasibility']:.3f}")
    
    # Optimize arrangement
    optimization = cytoplasm.optimize_arrangement()
    if optimization['optimization_valid']:
        print(f"Performance improvement: {optimization['performance_improvement']:.2%}")
    
    # Plot results
    cytoplasm.plot_analysis()
    
    # Save results
    with open('hegel_results.json', 'w') as f:
        json.dump({
            'feasibility': feasibility['overall_feasibility'],
            'oxygen_molecules': len(cytoplasm.oxygen_molecules),
            'reactions': len(cytoplasm.reactions)
        }, f, indent=2)
    
    print("âœ… Hegel analysis complete!")

if __name__ == "__main__":
    main()
